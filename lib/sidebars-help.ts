import {
  NavBarItem,
  NavBarItemType,
  SidebarItem,
  SidebarItemType,
  Sidebars,
} from "./types";
import LibControllerImpl from "./index";
import path from "path";
import fs from "fs";

class SidebarsController {
  static _instance: SidebarsController;
  _sidebarsMap: Record<string, Record<string, Sidebars>>;
  _usedSidebarIdsMap: Record<string, string[]> = {};
  static getInstance() {
    return (
      SidebarsController._instance ||
      (SidebarsController._instance = new SidebarsController())
    );
  }
  getSidebars(instanceID: string, docVersion?: string) {
    if (
      !this._sidebarsMap ||
      !this._sidebarsMap[instanceID] ||
      !this._sidebarsMap[instanceID][docVersion]
    ) {
      let result: Sidebars = null;
      let rootUrl = `${LibControllerImpl.getEntityRootDirectory()}/${
        instanceID === "default" ? "" : instanceID + "_"
      }docs`;
      if (docVersion) {
        rootUrl = `${LibControllerImpl.getEntityRootDirectory()}/${
          instanceID === "default" ? "" : instanceID + "_"
        }versioned_docs/version-${docVersion}`;
      }
      const rootPath = path.resolve("./public", "..", rootUrl);

      if (fs.existsSync(rootPath)) {
        const sidebarsUrl = `${rootUrl}/sidebars.json`;
        const sidebarsPath = path.resolve("./public", "..", sidebarsUrl);
        if (fs.existsSync(sidebarsPath)) {
          const sidebarsObj: Sidebars = JSON.parse(
            fs.readFileSync(sidebarsPath, "utf8")
          );
          Object.keys(sidebarsObj).forEach((key) => {
            const firstSidebarItem = sidebarsObj[key][0];
            if (
              typeof firstSidebarItem === "object" &&
              firstSidebarItem.type === SidebarItemType.Autogenerated
            ) {
              // Add autogenerated sidebar
              sidebarsObj[key] = this.generatedSidebar(
                rootUrl,
                firstSidebarItem.dirName
              );
            } else {
              this.transSidebarItemStringToObj(sidebarsObj[key]);
            }
          });
          result = sidebarsObj;
        } else {
          // No is generated by directory by default
          const defaultSidebar = {
            mySidebar: this.generatedSidebar(rootUrl, "."),
          };
          result = defaultSidebar;
        }
      } else {
        console.error(
          `[DocsController]getSidebars: The document directory for the instance was not found `,
          instanceID
        );
      }
      console.log(`[DocsController]getSidebars: `, JSON.stringify(result));
      this._sidebarsMap = this._sidebarsMap || {};
      this._sidebarsMap[instanceID] = this._sidebarsMap[instanceID] || {};
      this._sidebarsMap[instanceID][docVersion] = result;
    }
    return this._sidebarsMap[instanceID][docVersion];
  }
  getUsedSidebarIds(instanceID: string) {
    if (!this._usedSidebarIdsMap[instanceID]) {
      const { themeConfig } = LibControllerImpl.getDocuoConfig();
      const { navbar } = themeConfig;
      const usedSidebarIds = [];
      const loop = (items: NavBarItem[], usedSidebarIds: string[]) => {
        for (const item of items) {
          !item.docsInstanceId && (item.docsInstanceId = "default");
          if (
            item.type === NavBarItemType.DocSidebar &&
            item.docsInstanceId === instanceID
          ) {
            usedSidebarIds.push(...item.sidebarIds);
          }
          if (item.items) {
            loop(item.items, usedSidebarIds);
          }
        }
      };
      loop(navbar.items, usedSidebarIds);
      // Remove duplicate elements
      this._usedSidebarIdsMap[instanceID] = usedSidebarIds.reduce(
        (prev, curr) => {
          if (!prev.includes(curr)) {
            prev.push(curr);
          }
          return prev;
        },
        []
      );
    }
    console.log(
      `[DocsController]getUsedSidebarIds: `,
      instanceID,
      this._usedSidebarIdsMap[instanceID]
    );
    return this._usedSidebarIdsMap[instanceID];
  }
  generatedSidebar(rootUrl: string, dirName: string) {
    const dirPath = path.resolve("./public", "..", rootUrl, dirName);
    console.log(`[DocsController]generatedSidebar: `, rootUrl, dirPath);
    const loop = (dirPath: string) => {
      const stats = fs.statSync(dirPath);
      if (!stats.isDirectory()) {
        const relativePath = path.relative(rootUrl, dirPath);
        const parsedPath = path.parse(relativePath);
        if (parsedPath.ext !== ".json") {
          return {
            type: "doc",
            id: path.join(parsedPath.dir, parsedPath.name),
            label: parsedPath.name,
          };
        } else {
          return null;
        }
      }
      const files = fs.readdirSync(dirPath);
      const sidebar = {
        type: "category",
        label: path.basename(dirPath, path.extname(dirPath)),
        items: [],
      };

      files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const childTreeData = loop(filePath);
        childTreeData && sidebar.items.push(childTreeData);
      });

      return sidebar;
    };
    const sidebar = (loop(dirPath) as SidebarItem).items;
    console.log(
      `[DocsController]generatedSidebar sidebar: `,
      JSON.stringify(sidebar)
    );
    return sidebar;
  }
  transSidebarItemStringToObj(sidebar: (string | SidebarItem)[]) {
    const loop = (items: (string | SidebarItem)[]) => {
      items.forEach((sidebarItem, index) => {
        if (typeof sidebarItem === "string") {
          items[index] = {
            type: SidebarItemType.Doc,
            id: sidebarItem,
            label: path.basename(sidebarItem),
          };
        } else {
          if (sidebarItem.items) {
            loop(sidebarItem.items);
          }
        }
      });
    };
    loop(sidebar);
  }
}
export default SidebarsController.getInstance();
