import {
  NavBarItem,
  NavBarItemType,
  SidebarItem,
  SidebarItemType,
  Sidebars,
} from "./types";
import LibControllerImpl from "./index";
import path from "path";
import fs from "fs";

class SidebarsController {
  static _instance: SidebarsController;
  _sidebarsMap: Record<string, Record<string, Sidebars>>;
  _usedSidebarIdsMap: Record<string, string[]> = {};
  static getInstance() {
    return (
      SidebarsController._instance ||
      (SidebarsController._instance = new SidebarsController())
    );
  }
  getSidebars(instanceID: string, docVersion?: string) {
    let result: Sidebars = null;
    let rootUrl = `${LibControllerImpl.getEntityRootDirectory()}/${
      instanceID === "default" ? "" : instanceID + "_"
    }docs`;
    if (docVersion) {
      rootUrl = `${LibControllerImpl.getEntityRootDirectory()}/${
        instanceID === "default" ? "" : instanceID + "_"
      }versioned_docs/version-${docVersion}`;
    }
    const rootPath = path.resolve("./public", "..", rootUrl);

    if (fs.existsSync(rootPath)) {
      const sidebarsUrl = `${rootUrl}/sidebars.json`;
      const sidebarsPath = path.resolve("./public", "..", sidebarsUrl);
      if (fs.existsSync(sidebarsPath)) {
        let sidebarsObj: Sidebars = JSON.parse(
          fs.readFileSync(sidebarsPath, "utf8")
        );
        if (Array.isArray(sidebarsObj)) {
          sidebarsObj = {
            mySidebar: JSON.parse(JSON.stringify(sidebarsObj)),
          };
        }
        Object.keys(sidebarsObj).forEach((key) => {
          this.transSidebarItem(rootUrl, sidebarsObj[key]);
        });
        result = sidebarsObj;
      } else {
        // No is generated by directory by default
        const defaultSidebar = {
          mySidebar: this.generatedSidebar(rootUrl, "."),
        };
        result = defaultSidebar;
      }
    } else {
      console.error(
        `[DocsController]getSidebars: The document directory for the instance was not found `,
        instanceID
      );
    }
    this._sidebarsMap = this._sidebarsMap || {};
    this._sidebarsMap[instanceID] = this._sidebarsMap[instanceID] || {};
    this._sidebarsMap[instanceID][docVersion] = result;
    return this._sidebarsMap[instanceID][docVersion];
  }
  getUsedSidebarIds(instanceID: string) {
    const { themeConfig } = LibControllerImpl.getDocuoConfig();
    if (!themeConfig) return []; // 容错
    const { navbar } = themeConfig;
    const usedSidebarIds = [];
    const loop = (items: NavBarItem[] = [], usedSidebarIds: string[]) => {
      if (items.length === 0) return;
      for (const item of items) {
        !item.docsInstanceId && (item.docsInstanceId = "default");
        if (
          item.type === NavBarItemType.DocSidebar &&
          item.docsInstanceId === instanceID
        ) {
          usedSidebarIds.push(...item.sidebarIds);
        }
        if (item.items) {
          loop(item.items, usedSidebarIds);
        }
      }
    };
    loop(navbar.items || [], usedSidebarIds);
    // Remove duplicate elements
    this._usedSidebarIdsMap[instanceID] = usedSidebarIds.reduce(
      (prev, curr) => {
        if (!prev.includes(curr)) {
          prev.push(curr);
        }
        return prev;
      },
      []
    );
    console.log(
      `[DocsController]getUsedSidebarIds: `,
      instanceID,
      this._usedSidebarIdsMap[instanceID]
    );
    return this._usedSidebarIdsMap[instanceID];
  }
  generatedSidebar(rootUrl: string, dirName: string) {
    const dirPath = path.resolve("./public", "..", rootUrl, dirName);
    const loop = (dirPath: string): SidebarItem => {
      const stats = fs.statSync(dirPath);
      if (!stats.isDirectory()) {
        const relativePath = path.relative(rootUrl, dirPath);
        const parsedPath = path.parse(relativePath);
        if (
          parsedPath.ext.toLocaleLowerCase() === ".mdx" ||
          parsedPath.ext.toLocaleLowerCase() === ".md"
        ) {
          const originID = path.join(parsedPath.dir, parsedPath.name);
          const id = this.convertDocID(path.normalize(originID));
          return {
            type: SidebarItemType.Doc,
            id,
            label: parsedPath.name,
          };
        } else {
          return null;
        }
      }
      const files = fs.readdirSync(dirPath);
      const sidebar: SidebarItem = {
        type: SidebarItemType.Category,
        label: path.basename(dirPath, path.extname(dirPath)),
        items: [],
      };

      files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const childTreeData = loop(filePath);
        childTreeData &&
          ((childTreeData.items && childTreeData.items.length) ||
            !childTreeData.items) &&
          sidebar.items.push(childTreeData);
      });
      return sidebar;
    };
    const sidebar = (loop(dirPath) as SidebarItem).items;
    return sidebar;
  }
  transSidebarItem(rootUrl: string, sidebar: (string | SidebarItem)[]) {
    const loop = (items: (string | SidebarItem)[]) => {
      for (let index = 0; index < items.length; index++) {
        let sidebarItem = items[index];
        if (typeof sidebarItem === "string") {
          // Remove suffix
          const suffixIndex = sidebarItem.lastIndexOf(".");
          suffixIndex !== -1 &&
            (sidebarItem = sidebarItem.slice(0, suffixIndex));
          sidebarItem = this.convertDocID(path.normalize(sidebarItem));
          items[index] = {
            type: SidebarItemType.Doc,
            id: sidebarItem,
            label: path.basename(sidebarItem),
          };
        } else {
          const abbreviationKey = this.isAbbreviation(sidebarItem);
          if (abbreviationKey) {
            sidebarItem.type = SidebarItemType.Category;
            sidebarItem.label = abbreviationKey;
            sidebarItem.items = sidebarItem[abbreviationKey];
            sidebarItem.collapsible = true;
            sidebarItem.collapsed = true;
          }
          if (sidebarItem.type === SidebarItemType.Autogenerated) {
            const temp = this.generatedSidebar(rootUrl, sidebarItem.dirName);
            items.splice(index, 1, ...temp);
            index += temp.length - 1;
          } else {
            if (sidebarItem.id) {
              // Remove suffix
              const suffixIndex = sidebarItem.id.lastIndexOf(".");
              suffixIndex !== -1 &&
                (sidebarItem.id = sidebarItem.id.slice(0, suffixIndex));
              sidebarItem.id = this.convertDocID(
                path.normalize(sidebarItem.id)
              );
            }
            if (sidebarItem.items) {
              loop(sidebarItem.items);
            }
          }
        }
      }
    };
    loop(sidebar);
  }
  isAbbreviation(sidebarItem: SidebarItem) {
    // Restriction 1: There is only one key-value pair
    // Restriction 2: Values must be arrays
    const keys = Object.keys(sidebarItem);
    const key = keys[0];
    const result =
      keys.length === 1 &&
      key !== "id" &&
      key !== "type" &&
      Array.isArray(sidebarItem[key]);
    return result ? key : "";
  }
  convertDocID(str: string) {
    // Quick Start, Quick-Start
    // Quick start, Quick-start
    // Quick start/Overview
    if (process.platform.includes("win")) {
      str = str.replace(/\\/g, "/");
    }
    const result = [];
    const temp = str.split("/");
    temp.forEach((path) => {
      result.push(path.toLowerCase().replace(/\s+/g, "-"));
    });
    return result.join("/");
  }
}
export default SidebarsController.getInstance();
