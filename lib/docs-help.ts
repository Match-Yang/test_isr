import fs from "fs";
import path from "path";
import inputDocuoConfig from "@/docs/docuo.config";
import {
  DocuoConfig,
  NavBarItem,
  NavBarItemType,
  SidebarItem,
  SidebarItemType,
  Sidebars,
} from "./types";
import { visit } from "unist-util-visit";
import { serialize } from "next-mdx-remote/serialize";
import remarkImages from "remark-images";
import { rehypeImages } from "@/plugins";

class DocsController {
  static _instance: DocsController;
  _UUID = "37e7bcb6-4fa7-431d-b11c-df9a1c26cf62";
  _docuoConfig: DocuoConfig;
  _sidebarsMap: Record<string, Record<string, Sidebars>>;
  _entityRootDirectory = "docs";
  _usedVersionsMap: Record<string, string[]> = {};
  _actualVersionsMap: Record<string, string[]> = {};
  _allSlugs: {
    params: { slug: string[]; instanceID: string; slugVersion: string };
  }[];
  _usedSidebarIdsMap: Record<string, string[]> = {};
  _defaultVersion = "next";
  static getInstance() {
    return (
      DocsController._instance ||
      (DocsController._instance = new DocsController())
    );
  }
  getDocuoConfig() {
    if (!this._docuoConfig) {
      // Complete the default value
      const docuoConfig: DocuoConfig = JSON.parse(
        JSON.stringify(inputDocuoConfig)
      );
      const defaultInstance = {
        id: "default", // Host instance
        label: "docs",
        path: "docs",
        routeBasePath: "docs",
      };
      if (!docuoConfig.instances) {
        docuoConfig.instances = [defaultInstance];
      } else {
        docuoConfig.instances.forEach((instance) => {
          if (!instance.id || instance.id === "default") {
            // Host instance
            instance.id = defaultInstance.id;
            instance.label = defaultInstance.label;
            instance.path = defaultInstance.path;
            instance.routeBasePath = defaultInstance.routeBasePath;
          }
          if (!instance.routeBasePath) {
            instance.routeBasePath = instance.path;
          }
        });
        const result = docuoConfig.instances.find(
          (instance) => instance.id === "default"
        );
        if (!result) {
          // Insert host instance
          docuoConfig.instances.unshift(defaultInstance);
        }
      }
      this._docuoConfig = docuoConfig;
    }
    return this._docuoConfig;
  }
  getSidebars(instanceID: string, docVersion?: string) {
    if (
      !this._sidebarsMap ||
      !this._sidebarsMap[instanceID] ||
      !this._sidebarsMap[instanceID][docVersion]
    ) {
      let result: Sidebars = null;
      let rootUrl = `${this._entityRootDirectory}/${
        instanceID === "default" ? "" : instanceID + "_"
      }docs`;
      if (docVersion) {
        rootUrl = `${this._entityRootDirectory}/${
          instanceID === "default" ? "" : instanceID + "_"
        }versioned_docs/version-${docVersion}`;
      }
      const rootPath = path.resolve("./public", "..", rootUrl);

      if (fs.existsSync(rootPath)) {
        const sidebarsUrl = `${rootUrl}/sidebars.json`;
        const sidebarsPath = path.resolve("./public", "..", sidebarsUrl);
        if (fs.existsSync(sidebarsPath)) {
          const sidebarsObj: Sidebars = JSON.parse(
            fs.readFileSync(sidebarsPath, "utf8")
          );
          Object.keys(sidebarsObj).forEach((key) => {
            const firstSidebarItem = sidebarsObj[key][0];
            if (
              typeof firstSidebarItem === "object" &&
              firstSidebarItem.type === SidebarItemType.Autogenerated
            ) {
              // Add autogenerated sidebar
              sidebarsObj[key] = this.generatedSidebar(
                rootUrl,
                firstSidebarItem.dirName
              );
            } else {
              this.transSidebarItemStringToObj(sidebarsObj[key]);
            }
          });
          result = sidebarsObj;
        } else {
          // No is generated by directory by default
          const defaultSidebar = {
            mySidebar: this.generatedSidebar(rootUrl, "."),
          };
          result = defaultSidebar;
        }
      } else {
        console.error(
          `[DocsController]getSidebars: The document directory for the instance was not found `,
          instanceID
        );
      }
      console.log(`[DocsController]getSidebars: `, JSON.stringify(result));
      this._sidebarsMap = this._sidebarsMap || {};
      this._sidebarsMap[instanceID] = this._sidebarsMap[instanceID] || {};
      this._sidebarsMap[instanceID][docVersion] = result;
    }
    return this._sidebarsMap[instanceID][docVersion];
  }
  generatedSidebar(rootUrl: string, dirName: string) {
    const dirPath = path.resolve("./public", "..", rootUrl, dirName);
    console.log(`[DocsController]generatedSidebar: `, rootUrl, dirPath);
    const loop = (dirPath: string) => {
      const stats = fs.statSync(dirPath);
      if (!stats.isDirectory()) {
        const relativePath = path.relative(rootUrl, dirPath);
        const parsedPath = path.parse(relativePath);
        if (parsedPath.ext !== ".json") {
          return {
            type: "doc",
            id: path.join(parsedPath.dir, parsedPath.name),
            label: parsedPath.name,
          };
        } else {
          return null;
        }
      }
      const files = fs.readdirSync(dirPath);
      const sidebar = {
        type: "category",
        label: path.basename(dirPath, path.extname(dirPath)),
        items: [],
      };

      files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const childTreeData = loop(filePath);
        childTreeData && sidebar.items.push(childTreeData);
      });

      return sidebar;
    };
    const sidebar = (loop(dirPath) as SidebarItem).items;
    console.log(
      `[DocsController]generatedSidebar sidebar: `,
      JSON.stringify(sidebar)
    );
    return sidebar;
  }
  transSidebarItemStringToObj(sidebar: (string | SidebarItem)[]) {
    const loop = (items: (string | SidebarItem)[]) => {
      items.forEach((sidebarItem, index) => {
        if (typeof sidebarItem === "string") {
          items[index] = {
            type: SidebarItemType.Doc,
            id: sidebarItem,
            label: path.basename(sidebarItem),
          };
        } else {
          if (sidebarItem.items) {
            loop(sidebarItem.items);
          }
        }
      });
    };
    loop(sidebar);
  }
  getUsedVersions(instanceID: string) {
    // Use the external current version if the file is not present or the list is empty
    if (!this._usedVersionsMap[instanceID]) {
      const { instances } = this.getDocuoConfig();
      const instance = instances.find((i) => i.id === instanceID);
      const versionsUrl = `${this._entityRootDirectory}/${
        instance.id === "default" ? "" : instance.id + "_"
      }versions.json`;
      const versionsPath = path.resolve("./public", "..", versionsUrl);
      let versions: string[] = [];
      if (fs.existsSync(versionsPath)) {
        versions = (
          JSON.parse(fs.readFileSync(versionsPath, "utf8")) as string[]
        ).filter((version) => version);
      }
      console.log(`[DocsController]getUsedVersions: `, versions);
      this._usedVersionsMap[instanceID] = versions;
    }
    return JSON.parse(
      JSON.stringify(this._usedVersionsMap[instanceID])
    ) as string[];
  }
  getActualVersions(instanceID: string) {
    if (!this._actualVersionsMap[instanceID]) {
      const { instances } = this.getDocuoConfig();
      const instance = instances.find((i) => i.id === instanceID);
      const versionedUrl = `${this._entityRootDirectory}/${
        instance.id === "default" ? "" : instance.id + "_"
      }versioned_docs`;
      const versionedPath = path.resolve("./public", "..", versionedUrl);
      let versioned: string[] = [];
      if (fs.existsSync(versionedPath)) {
        const files = fs.readdirSync(versionedPath);
        versioned = files.map((file) => {
          const temp = file.split("-");
          temp.shift();
          return temp.join("-");
        });
      } else {
        // There is only one default version
        console.error(
          `[DocsController]getActualVersions: No version is currently defined `,
          instanceID
        );
      }
      console.error(`[DocsController]getActualVersions: `, versioned);
      this._actualVersionsMap[instanceID] = versioned;
    }
    return this._actualVersionsMap[instanceID];
  }
  getUsedSidebarIds(instanceID: string) {
    if (!this._usedSidebarIdsMap[instanceID]) {
      const { themeConfig } = this.getDocuoConfig();
      const { navbar } = themeConfig;
      const usedSidebarIds = [];
      const loop = (items: NavBarItem[], usedSidebarIds: string[]) => {
        for (const item of items) {
          !item.docsInstanceId && (item.docsInstanceId = "default");
          if (
            item.type === NavBarItemType.DocSidebar &&
            item.docsInstanceId === instanceID
          ) {
            usedSidebarIds.push(...item.sidebarIds);
          }
          if (item.items) {
            loop(item.items, usedSidebarIds);
          }
        }
      };
      loop(navbar.items, usedSidebarIds);
      // Remove duplicate elements
      this._usedSidebarIdsMap[instanceID] = usedSidebarIds.reduce(
        (prev, curr) => {
          if (!prev.includes(curr)) {
            prev.push(curr);
          }
          return prev;
        },
        []
      );
    }
    console.log(
      `[DocsController]getUsedSidebarIds: `,
      instanceID,
      this._usedSidebarIdsMap[instanceID]
    );
    return this._usedSidebarIdsMap[instanceID];
  }
  getAllSlugs() {
    if (!this._allSlugs) {
      let allSlugs: {
        params: { slug: string[]; instanceID: string; slugVersion: string };
      }[] = [];
      const { instances } = this.getDocuoConfig();
      for (const instance of instances) {
        const slugs = this.getSlugs(instance.id);
        allSlugs = allSlugs.concat(slugs);
      }
      console.log(`[DocsController]getAllSlugs: `, JSON.stringify(allSlugs));
      this._allSlugs = allSlugs;
    }
    return this._allSlugs;
  }
  getSlugs(instanceID: string) {
    // eg: instance routeBasePath/version/folder/filename
    const { instances } = this.getDocuoConfig();
    const instance = instances.find((i) => i.id === instanceID);
    const usedSidebarIds = this.getUsedSidebarIds(instanceID);
    let slugs: {
      params: { slug: string[]; instanceID: string; slugVersion: string };
    }[] = [];
    const slugVersions = this.getUsedVersions(instanceID);
    if (!slugVersions.length) {
      // [""]
      slugVersions.push("");
    } else {
      // ["next", "1.1.0", "1.0.0"]
      slugVersions.unshift(this._defaultVersion);
      slugVersions[1] = this.docVersionToSlugVersion(
        instanceID,
        slugVersions[1]
      );
    }
    console.log(`[DocsController]getSlugs slugVersions: `, slugVersions);

    for (let index = 0, len = slugVersions.length; index < len; index++) {
      let preSlug = [instance.routeBasePath];
      const slugVersion = slugVersions[index];
      slugVersion && (preSlug = preSlug.concat([slugVersion]));
      const sidebars = this.getSidebars(
        instanceID,
        this.slugVersionToDocVersion(instanceID, slugVersion)
      );
      for (const sidebarId of usedSidebarIds) {
        const sidebarItemList = sidebars[sidebarId] as SidebarItem[];
        slugs = slugs.concat(
          this.traverseChildren(
            instanceID,
            slugVersion,
            sidebarId,
            sidebarItemList,
            preSlug
          )
        );
      }
    }
    console.log(`[DocsController]getSlugs: `, JSON.stringify(slugs));
    return slugs;
  }
  traverseChildren(
    instanceID: string,
    slugVersion: string,
    sidebarId: string,
    sidebarItemList: SidebarItem[],
    preSlug: string[]
  ) {
    const result: {
      params: {
        slug: string[];
        instanceID: string;
        slugVersion: string;
        sidebarId: string;
      };
    }[] = [];
    for (const sidebarItem of sidebarItemList) {
      if (sidebarItem.items) {
        result.push(
          ...this.traverseChildren(
            instanceID,
            slugVersion,
            sidebarId,
            sidebarItem.items as SidebarItem[],
            preSlug
          )
        );
      }
      if (sidebarItem.type === SidebarItemType.Doc) {
        const itemSlug = sidebarItem.id.split("/");
        const slug = [...preSlug, ...itemSlug];
        result.push({
          params: {
            instanceID,
            slugVersion,
            sidebarId,
            slug,
          },
        });
      }
    }
    return result;
  }
  async readDoc(slug: string[]) {
    console.log(`[DocsController]readDoc `, slug);
    const { docVersion, mdxFileID, instanceID, slugVersion } =
      this.extractInfoFromSlug(slug);
    const versions = this.getUsedVersions(instanceID);

    let originContent =
      "The conversion of the article content encountered an exception and cannot be displayed.";

    if (!slugVersion || slugVersion !== versions[0]) {
      let mdxFileUrl = `${this._entityRootDirectory}/${
        instanceID === "default" ? "" : instanceID + "_"
      }docs/${mdxFileID}.mdx`;
      if (docVersion) {
        mdxFileUrl = `${this._entityRootDirectory}/${
          instanceID === "default" ? "" : instanceID + "_"
        }versioned_docs/version-${docVersion}/${mdxFileID}.mdx`;
      }
      const mdxFilePath = path.resolve("./public", "..", mdxFileUrl);
      if (fs.existsSync(mdxFilePath)) {
        originContent = fs.readFileSync(
          path.resolve("./public", "..", mdxFileUrl),
          "utf8"
        );
      }
    }
    originContent = originContent
      .replace(
        /```(\S*?\s)([\s\S]*?)(```)(?=\n<\/SCodeBlock>)/gm,
        (_, lang, code) => {
          code = code.replace(/```/g, this._UUID);
          return "```" + lang + code + "```";
        }
      )
      .replaceAll("&nbsp;", " ");
    const myRemarkPlugin = () => {
      return (tree) => {
        visit(tree, "code", (node) => {
          if (typeof node.value === "string") {
            node.value = node.value.replaceAll(this._UUID, "```");
          }
        });
      };
    };
    const mdxSource = await serialize(originContent, {
      mdxOptions: {
        remarkPlugins: [remarkImages, myRemarkPlugin],
        rehypePlugins: [
          [rehypeImages, { baseDir: process.cwd(), filePath: mdxFileUrl }],
        ],
        format: "mdx",
        useDynamicImport: true,
      },
      parseFrontmatter: true,
    });
    return {
      slug,
      mdxSource,
    };
  }
  extractInfoFromSlug(slug: string[]) {
    // eg1: /docs/path/to/doc => The current version when there is no version list
    // eg2: /docs/path/to/doc => The latest version when the version list is available
    // eg3: /docs/next/path/to/doc => The current version when the version list is available
    // eg4: /docs/1.0.0/path/to/doc => The specified version when there is a version list
    const docuoConfig = this.getDocuoConfig();
    const routeBasePath = slug[0];
    const instanceID = docuoConfig.instances.find(
      (instance) => instance.routeBasePath === routeBasePath
    ).id;
    const versions = this.getUsedVersions(instanceID);
    let slugVersion = slug[1];
    let mdxFileID = slug.slice(2).join("/");
    const mdxFileName = slug[slug.length - 1];
    if (!versions.length) {
      slugVersion = "";
      mdxFileID = slug.slice(1).join("/");
    } else {
      if (slugVersion !== this._defaultVersion) {
        if (!versions.includes(slugVersion)) {
          slugVersion = "";
          mdxFileID = slug.slice(1).join("/");
        }
      }
    }
    return {
      instanceID,
      routeBasePath,
      slugVersion,
      docVersion: this.slugVersionToDocVersion(instanceID, slugVersion),
      mdxFileID,
      mdxFileName,
    };
  }
  getFolderTreeDataBySlug(slug: string[]) {
    const { instanceID, routeBasePath, docVersion, slugVersion } =
      this.extractInfoFromSlug(slug);
    console.log(
      `[DocsController]getFolderTreeDataBySlug slug `,
      slug,
      this.extractInfoFromSlug(slug)
    );
    let tree = [];

    const versions = this.getUsedVersions(instanceID);
    if (slugVersion && slugVersion === versions[0]) {
      tree = [];
    } else {
      const usedSidebarIds = this.getUsedSidebarIds(instanceID);
      const sidebars = this.getSidebars(instanceID, docVersion);
      usedSidebarIds.forEach((sidebarId) => {
        const sidebarItems = sidebars[sidebarId];
        const prefixKey = `${routeBasePath}${
          slugVersion ? "/" : ""
        }${slugVersion}/${sidebarId}`;
        const idPrefixKey = `${routeBasePath}${
          slugVersion ? "/" : ""
        }${slugVersion}`;
        tree = tree.concat(
          this.getChildrenFromChildren(
            sidebarItems as SidebarItem[],
            prefixKey,
            idPrefixKey,
            instanceID,
            docVersion,
            slugVersion
          )
        );
      });
    }
    console.log(
      `[lib/folder-tree]getFolderTreeDataBySlug: `,
      instanceID,
      docVersion,
      slugVersion,
      JSON.stringify(tree)
    );
    return tree;
  }
  getChildrenFromChildren(
    sidebarItems: SidebarItem[],
    prefixKey: string,
    idPrefixKey,
    instanceID,
    docVersion,
    slugVersion
  ) {
    prefixKey = prefixKey || "";
    idPrefixKey = idPrefixKey || "";
    const result = [];
    for (const item of sidebarItems) {
      let children;
      if (item.items) {
        children = this.getChildrenFromChildren(
          item.items as SidebarItem[],
          `${prefixKey}${prefixKey ? "/" : ""}${item.label}`,
          idPrefixKey,
          instanceID,
          docVersion,
          slugVersion
        );
      }
      if (
        item.type === SidebarItemType.Doc ||
        item.type === SidebarItemType.Category
      ) {
        const temp: any = {
          title: item.label,
          type: item.type,
          key: `${prefixKey}${prefixKey ? "/" : ""}${item.label}`,
          instanceID,
          docVersion,
          slugVersion,
        };
        children && (temp.children = children);
        item.type === SidebarItemType.Doc &&
          (temp.id = `${idPrefixKey}/${item.id}`);
        result.push(temp);
      } else {
        result.push({
          title: item.label,
          type: item.type,
          key: `${prefixKey}${prefixKey ? "/" : ""}${item.label}`,
          link: item.href || item.to,
          instanceID,
          docVersion,
          slugVersion,
        });
      }
    }
    return result;
  }
  slugVersionToDocVersion(instanceID: string, slugVersion: string) {
    // slugVersion: "next", ""("1.1.0"), "1.0.0",
    const versions = this.getUsedVersions(instanceID);
    let docVersion;
    if (versions.length) {
      if (!slugVersion) {
        docVersion = versions[0];
      } else if (slugVersion === this._defaultVersion) {
        docVersion = "";
      } else {
        docVersion = slugVersion;
      }
    } else {
      docVersion = "";
    }
    return docVersion;
  }
  docVersionToSlugVersion(instanceID: string, docVersion: string) {
    // docVersion: "", "1.1.0", "1.0.0"
    const versions = this.getUsedVersions(instanceID);
    let slugVersion;
    if (versions.length) {
      if (docVersion === versions[0]) {
        slugVersion = "";
      } else if (!docVersion) {
        slugVersion = this._defaultVersion;
      } else {
        slugVersion = docVersion;
      }
    } else {
      slugVersion = "";
    }
    console.log(
      `[DocsController]getSlugs docVersionToSlugVersion: `,
      versions,
      docVersion,
      slugVersion
    );
    return slugVersion;
  }
}

export default DocsController.getInstance();
